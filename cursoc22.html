<HTML><!-- InstanceBegin template="/Templates/plantilla.dwt" codeOutsideHTMLIsLocked="false" -->

<HEAD>
     <!-- InstanceBeginEditable name="doctitle" -->
     <TITLE>Curso de C - Listas enlazadas simples (I)</TITLE>
     <!-- InstanceEndEditable -->
     <meta name="decription" content="Curso de C - Introducci�n">
     <meta name="keywords" content="Programaci&oacute;n, Curso de C, C">
     <META NAME="GENERATOR" CONTENT="Arachnophilia 3.5">
     <META NAME="FORMATTER" CONTENT="Arachnophilia 3.5">
     <meta name="author" content="Gorka Urrutia">
     <meta name="DC.Creator" content="Gorka Urrutia">
     <META name="robots" content="noindex, nofollow">
     <link rel="stylesheet" href="cursoc.css">
     <!-- InstanceBeginEditable name="head" -->


     <!-- InstanceEndEditable -->
</HEAD>

<BODY>
     <a name="arriba"></a>

     <table width="100%" border="0">
          <tr>
               <td align="left"><img src="cursoc.gif" alt="Curso de C" border="0">
               </td>
               <td align="right"><a href="http://www.elrincondelc.com" target="_top"><img src="colibri.gif"
                              alt="El Rinc�n del C - www.elrincondelc.com" border="0"></a>
               </td>
          </tr>
     </table>
     <!-- InstanceBeginEditable name="Titulo" -->
     <h1>Listas enlazadas simples (I)</h1><!-- InstanceEndEditable -->


     <p class="barranavegaciontop"><!-- InstanceBeginEditable name="BarraNavegacion" -->
          <a href="cursoc21.html">[Anterior]</a> <a href="cursoc-buenas.html">[Siguiente]</a>
          <a href="index.html" target="_top">[Contenido]</a>
          <!-- InstanceEndEditable -->
     </p>

     <!-- InstanceBeginEditable name="Cuerpo" -->

     <H2>
          Contenido
     </H2>

     <UL>
          <LI><A HREF="#intro" CLASS="enlace">Introducción</A>
          <LI><A HREF="#funciona" CLASS="enlace">Cómo funciona una lista</A>
          <LI><A HREF="#crear" CLASS="enlace">Ejemplo de una lista simple</A>
          <LI><A HREF="#anadir" CLASS="enlace">Añadir nuevos elementos</A>
          <LI><A HREF="#mostrar" CLASS="enlace">Mostrar la lista completa</A>
     </UL>

     <A NAME="intro"></A>
     <H2>
          Introducción
     </H2>

     <p>En el capítulo de 'Asignación dinámica de memoria' vimos que para ahorrar memoria podíamos reservarla
          dinámicamente (sobre la marcha). En mayor parte de los ejemplos que hemos visto hasta ahora reservabamos la
          memoria que íbamos a usar al comenzar el programa (al definir las variables).</p>

     <p>El problema surge a la hora de hacer un programa al estilo de una agenda. No sabemos a priori cuántos nombres
          vamos a meter en la agenda, así que si usamos un array para este programa podemos quedarnos cortos o pasarnos.
          Si por ejemplo creamos una agenda con un array de mil elementos (que pueda contener mil números) y usamos sólo
          100 estamos desperdiciando una cantidad de memoria importante. Si por el contrario decidimos crear una agenda
          con sólo 100 elementos para ahorrar memoria y necesitamos 200 nos vamos a quedar cortos. La mejor solución
          para este tipo de programas son las <b>listas enlazadas</b>.</p>

     <p>En una lista enlazada la memoria se va tomando segun se necesita. Cuando queremos añadir un nuevo elemento
          reservamos memoria para él y lo añadimos a la lista. Cuando queremos eliminar el elemento simplemente lo
          sacamos de la lista y liberamos la memoria usada.</p>

     <p>Las listas enlazadas pueden ser simples, dobles o circulares. En este capítulo y el siguiente vamos a ver sólo
          las listas simples.</p>

     <p class="volver"><a href="#arriba">[Arriba]</a></p>

     <A NAME="funciona"></A>
     <H2>
          Cómo funciona una lista
     </H2>

     <p>Para crear una lista necesitamos recordar nuestros conocimientos sobre estructuras y asignación dinámica de
          memoria. Vamos a desarrollar este tema creando una sencilla agenda que contiene el nombre y el número de
          teléfono.</p>

     <p>Una lista enlazada simple necesita una estructura con varios campos, los campos que contienen los datos
          necesarios (nombre y teléfono) y otro campo que contiene un puntero a la propia estructura. Este puntero se
          usa para saber dónde está el siguiente elemento de la lista, para saber la posición en memoria del siguiente
          elemento.</p>

     <div CLASS="ejemplo">
          <pre>
 struct _agenda {
        char nombre[20];
        char telefono[12];
        struct _agenda *siguiente;
        };</pre>
          <span CLASS="comprobado">Comprobado con DJGPP</span>
     </div>

     <p>Podríamos representar la estructura algo así:</p>

     <center><img src="listas1.gif" alt="representaci�n de un elemento gen�rico de la lista"></center>

     <p>Ahora supongamos que añadimos un elemento a la lista, por ejemplo mis datos: nombre="Gorka Urrutia",
          telefono="99 429 31 23" (el teléfono es totalmente falso :-). Lo primero que debemos hacer es reservar (con la
          función malloc que ya hemos visto) un espacio en memoria para almacenar el elemento. Supongamos que se
          almacena en la posición 3000 (por decir un número cualquiera). El puntero <i>siguiente</i> debe apuntar a
          NULL, ya que no hay más elementos en la lista. El elemento quedaría así:</p>

     <center><img src="listas2.gif" alt="representaci�n de un elemento de la lista"></center>

     <p>Ahora añadimos un nuevo elemento: nombre="Alberto López" telefono="99 999 99 99". Hay que reservar (con malloc)
          memoria para este nuevo elemento. Vamos a imaginar que este elemento se guarda en la posición de la memoria
          número 3420. La lista quedaría así:</p>

     <center><img src="listas3.gif" alt="Lista con dos elementos"></center>

     <p>Lo primero que debemos hacer es reservar la memoria para el elemento, luego se le rellenan los datos, se pone el
          puntero <i>siguiente</i> apuntando a NULL (porque será el último), y decir al elemento anterior que apunte al
          elemento que hemos añadido.</p>

     <p>Si quisieramos mostrar en pantalla la lista comenzareamos por el primer elemento, lo imprimiéramos y con el
          puntero siguiente saltareamos al segundo elemento, y así hasta que el puntero <i>siguiente</i> apunte a NULL.
     </p>

     <p>Siempre debemos tener un puntero del tipo _agenda para recordar la posición en memoria del primer elemento de la
          lista. Si perdemos este puntero perderemos la lista completa, así que mucho cuidado. Este puntero se definiría
          así:</p>

     <DIV CLASS="ejemplo">
          <PRE>
 struct _agenda primero;
 </pre>
     </DIV>

     <p>Añadiendo otro elemento más:</p>

     <center><img src="listas4.gif" alt="Lista con tres elementos"></center>

     <p class="volver"><a href="#arriba">[Arriba]</a></p>

     <A NAME="crear"></A>
     <H2>
          Ejemplo de una lista simple
     </H2>

     <p>Para estudiar el funcionamiento de una lista simple vamos a usar el programa agenda que hemos comentado arriba.
          Existen otras formas de implementar una lista simple, pero la que uso en el programa me ha parecido la más
          sencilla para exlicar su funcionamiento. El programa utiliza dos funciones muy importantes:</p>

     <dl class=texto>
          <dt>anadir_elemento
          <dd>esta función se encarga de añadir nuevos elementos a la lista.

          <dt>mostrar_lista
          <dd>recorre la lista entera y muestra todos sus elementos en la pantalla.

     </dl>

     <p>Estas dos funciones se explican en los siguientes apartados. Echa una ojeada al código y pasa al <a
               href="#anadir">siguiente apartado</a>.</p>

     <p>Para controlar la lista usamos dos punteros, *primero y *ultimo. Como podrás imaginar el primero guarda la
          posición del primer elemento y el segundo la del último.</p>

     <DIV CLASS="ejemplo">
          <PRE>
 #include &lt;stdio.h&gt;
 
 struct _agenda {
        char nombre[20];
        char telefono[12];
        struct _agenda *siguiente;
        };
 
 struct _agenda *primero, *ultimo;
 
 void mostrar_menu() {
      printf("\n\nMenú:\n=====\n\n");
      printf("1.- Añadir elementos\n");
      printf("2.- Borrar elementos\n");
      printf("3.- Mostrar lista\n");
      printf("4.- Salir\n\n");
      printf("Escoge una opción: ");fflush(stdout);
 }
 
 /* Con esta función añadimos un elemento al final de la lista */
 void anadir_elemento() {
      struct _agenda *nuevo;
 
      /* reservamos memoria para el nuevo elemento */
      nuevo = (struct _agenda *) malloc (sizeof(struct _agenda));
      if (nuevo==NULL) printf( "No hay memoria disponible!\n");
 
      printf("\nNuevo elemento:\n");
      printf("Nombre: "); fflush(stdout);
      gets(nuevo-&gt;nombre);
      printf("Teléfono: "); fflush(stdout);
      gets(nuevo-&gt;telefono);
 
      /* el campo siguiente va a ser NULL por ser el último elemento
         de la lista */
      nuevo-&gt;siguiente = NULL;
 
      /* ahora metemos el nuevo elemento en la lista. lo situamos
         al final de la lista */
      /* comprobamos si la lista está vacía. si primero==NULL es que no
         hay ningún elemento en la lista. también vale ultimo==NULL */
      if (primero==NULL) {
         printf( "Primer elemento\n");
         primero = nuevo;
         ultimo = nuevo;
         }
      else {
           /* el que hasta ahora era el último tiene que apuntar al nuevo */
           ultimo-&gt;siguiente = nuevo;
           /* hacemos que el nuevo sea ahora el último */
           ultimo = nuevo;
      }
 }
 
 void mostrar_lista() {
      struct _agenda *auxiliar; /* lo usamos para recorrer la lista */
      int i;
 
      i=0;
      auxiliar = primero;
      printf("\nMostrando la lista completa:\n");
      while (auxiliar!=NULL) {
            printf( "Nombre: %s, Telefono: %s\n",
                    auxiliar->nombre,auxiliar-&gt;telefono);
            auxiliar = auxiliar-&gt;siguiente;
            i++;
      }
      if (i==0) printf( "\nLa lista está vacía!!\n" );
 }
 
 int main() {
     char opcion;
 
     primero = (struct _agenda *) NULL;
     ultimo = (struct _agenda *) NULL;
     do {
         mostrar_menu();
         opcion = getch();
             switch ( opcion ) {
                case '1': anadir_elemento();
                       break;
                case '2':  printf("No disponible todavía!\n");
                        break;
                case '3': mostrar_lista(primero);
                        break;
                case '4': exit( 1 );
                default: printf( "Opción no válida\n" );
                         break;
             }
     } while (opcion!='4');
 }</pre>
          <DIV CLASS="comprobado">Comprobado con DJGPP</DIV>
     </DIV>

     <p class="volver"><a href="#arriba">[Arriba]</a></p>

     <A NAME="anadir"></A>
     <H2>
          Añadir nuevos elementos
     </H2>

     <p>Reproducimos aquí de nuevo el código de la función <i>anadir_elemento</i>.</p>

     <p>Lo primero creamos un puntero que apuntará al nuevo elemento que vamos a añadir:</p>

     <DIV CLASS="ejemplo">
          <PRE>
      struct _agenda *nuevo;
 </pre>
     </div>

     <p>Una vez creado el puntero tenemos que reservar un espacio en memoria donde se almacenará el nuevo elemento. Este
          espacio debe ser del tamaño de la estructura, que lo conocemos usando "sizeof(struct _agenda)". Hacemos que el
          puntero guarde la posición de ese espacio reservado.</p>

     <p>Por supuesto comprobamos el valor del puntero para saber si la operación se ha realizado con éxito. Si no hay
          memoria suficiente para el puntero éste tomará el valor NULL.</p>

     <DIV CLASS="ejemplo">
          <PRE>
      /* reservamos memoria para el nuevo elemento */
      nuevo = (struct _agenda *) malloc (sizeof(struct _agenda));
      if (nuevo==NULL) printf( "No hay memoria disponible!\n");
 </pre>
     </div>

     <p>El siguiente paso es pedir al usuario del programa que meta los datos. Estos datos se almacenarán directamente
          en la memoria que hemos reservado gracias al puntero que usamos.</p>

     <DIV CLASS="ejemplo">
          <PRE>
      printf("\nNuevo elemento:\n");
      printf("Nombre: "); fflush(stdout);
      gets(nuevo-&gt;nombre);
      printf("Teléfono: "); fflush(stdout);
      gets(nuevo-&gt;telefono);
 </pre>
     </div>

     <p>El último elemento de la lista siempre va a apuntar a NULL, de esta forma sabemos cuál es el último elemento.
          Dado que en este ejemplo vamos a meter los elementos siempre al final de la lista, el campo <i>siguiente</i>
          tiene que ser NULL.</p>

     <DIV CLASS="ejemplo">
          <PRE>
      /* el campo siguiente va a ser NULL por ser el último elemento
         de la lista */
      nuevo-&gt;siguiente = NULL;
 </pre>
     </div>

     <p>El último paso es meter el elemento dentro de la lista (hasta ahora sólo teníamos un elemento aislado, que nada
          tenía que ver con la lista).</p>

     <p>Antes de meterlo en la lista debemos comprobar si ya existía algún elemento antes. Para ello vamos a comprobar
          el valor del puntero <i>primero</i> que deberia apuntar al primer elemento. Si <i>primero</i> es NULL eso
          significa que no hay ningún elemento en la lista, así que el nuevo elemento será a la vez el primero y el
          último de la lista:</p>

     <DIV CLASS="ejemplo">
          <PRE>
      /* ahora metemos el nuevo elemento en la lista. lo situamos
         al final de la lista */
      /* comprobamos si la lista está vacía. si primero==NULL es que no
         hay ningún elemento en la lista. también vale ultimo==NULL */
      if (primero==NULL) {
         printf( "Primer elemento\n");
         primero = nuevo;
         ultimo = nuevo;
         }
 </pre>
     </div>

     <p>Si ya existía algún elemento, debemos situar el nuevo elemento después del último. Para ello hacemos que el
          campo <i>siguiente</i> del último elemento apunte al nuevo elemento (ultimo-&gt;siguiente = nuevo;). Una vez
          hecho esto hacemos que el nuevo elemento sea el último de la lista (ultimo = nuevo;).</p>

     <DIV CLASS="ejemplo">
          <PRE>
      else {
           /* el que hasta ahora era el último tiene que apuntar al nuevo */
           ultimo-&gt;siguiente = nuevo;
           /* hacemos que el nuevo sea ahora el último */
           ultimo = nuevo;
      }
 }
 </pre>
          <!-- Creado el 22/3/2001 por Gorka Urrutia Landa. http://www.elrincondelc.com -->
     </div>


     <p class="volver"><a href="#arriba">[Arriba]</a></p>

     <A NAME="mostrar"></A>
     <H2>
          Mostrar la lista completa
     </H2>

     <p>Ya tenemos la forma de añadir elementos a una lista, ahora vamos a ver cómo recorrer la lista y mostrar su
          contenido.</p>

     <p>Para recorrer la lista usaremos un puntero auxiliar al que en un ataque de rabiosa originalidad llamaremos
          <i>auxiliar</i>.

     <p>Para comenzar debemos hacer que 'auxiliar' apunte al primer elemento de la lista (auxiliar=primero). Para
          recorrer la lista usamos un bucle while y comprobamos el valor de 'auxiliar'. Hemos visto que el campo
          'siguiente' del último elemento apuntaba a NULL, por lo tanto, cuando 'auxiliar' sea NULL sabremos que hemos
          llegado al final de la lista.</p>

     <p>En cada vuelta del ciclo mostramos el elemento actual y saltamos al siguiente. El campo 'siguiente' del puntero
          'auxiliar' contiene la dirección del siguiente elemento. Si hacemos que 'auxiliar' salte a la dirección
          almacenada en 'auxiliar->siguiente' estaremos en el siguiente elemento.</p>

     <p>Es importante no olvidar saltar al siguiente elemento, puesto que si no lo hacemos así no habrá forma de salir
          del bucle (estaremos siempre en el primer elemento).</p>

     <p>Como curiosidad se ha añadido una variable <i>i</i> con la que se cuenta el número de elementos de la lista. Si
          al final del bucle 'i' es cero, significa que no hay elementos en la lista.</p>

     <DIV CLASS="ejemplo">
          <PRE>
 void mostrar_lista() {
      struct _agenda *auxiliar; /* lo usamos para recorrer la lista */
      int i;
 
      i=0;
      auxiliar = primero;
      printf("\nMostrando la lista completa:\n");
      while (auxiliar!=NULL) {
            printf( "Nombre: %s, Telefono: %s\n",
                    auxiliar->nombre,auxiliar-&gt;telefono);
            auxiliar = auxiliar-&gt;siguiente;
            i++;
      }
      if (i==0) printf( "\nLa lista está vacía!!\n" );
 }
 </pre>
     </DIV>

     <!-- Creado el 22/3/2001 por Gorka Urrutia Landa. http://www.elrincondelc.com -->



     <p class="volver"><a href="#arriba">[Arriba]</a></p>

     <!-- InstanceEndEditable -->
     <p class="barranavegacionabajo"><!-- InstanceBeginEditable name="PieNavegacion" -->
          <a href="cursoc21.html">[Anterior]</a> <a href="cursoc-buenas.html">[Siguiente]</a>
          <a href="index.html" target="_top">[Contenido]</a>
          <A HREF="mailto:cursoc@elrincondelc.com" class="nombre">
               -----------------------------------------------------------------------------------------------------------------
               ISC.
               Jose Nicolas Jimenez Hernandez</A>
          <!-- InstanceEndEditable -->
     </p>
</BODY>

<!-- InstanceEnd -->

</HTML>